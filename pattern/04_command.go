package main

import "fmt"

/*
	Command поведенческий паттерн проектирования, который превращает запросы в объекты,
	позволяя передавать их как аргументы при вызове методов,
	ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
	Применимость:
	1) Когда необходимо параметризовать объекты выполняемым действием.
	2) Когда необходимо ставить операции в очередь, выполнять их по расписанию или передавать по сети.
	3) Когда нужна операция отмены.
	Плюсы:
	1) Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
	2) Позволяет реализовать простую отмену и повтор операций.
	3) Позволяет реализовать отложенный запуск операций.
	4) Позволяет собирать сложные команды из простых.
	Минусы:
	1) Усложняет код программы из-за введения множества дополнительных классов.
*/

type Button struct { // Отправитель хранит ссылку на объект команды и обращается к нему, когда нужно выполнить какое-то действие.
	command Command // Отправитель работает с командами только через их общий интерфейс.
	// Он не знает, какую конкретно команду использует, так как получает готовый объект команды от клиента.
}

func (b *Button) press() {
	b.command.execute()
}

type Command interface { // Интерфейс команды описывает общий для всех конкретных команд интерфейс.
	execute() // Обычно здесь описан всего один метод для запуска команды.
}

type OnCommand struct { // Конкретная команда. реализуют различные запросы, следуя общему интерфейсу команд.
	device Device // Обычно команда не делает всю работу самостоятельно, а лишь передаёт вызов получателю,
	// которым является один из объектов бизнес-логики. Параметры, с которыми команда обращается к получателю, следует хранить в виде полей
	// В большинстве случаев объекты команд можно сделать неизменяемыми, передавая в них все необходимые параметры только через конструктор.
}

func (c *OnCommand) execute() {
	c.device.on()
}

type OffCommand struct { // Конкретная команда
	device Device
}

func (c *OffCommand) execute() {
	c.device.off()
}

type Device interface { // Интерфейс получателя.
	on()
	off()
}

type Tv struct { // Конкретный получатель. содержит бизнес-логику программы.
	isRunning bool // В этой роли может выступать практически любой объект.
	// Обычно команды перенаправляют вызовы получателям.
	// Но иногда, чтобы упростить программу, можно избавиться от получателей, распределив их код в классы команд.
}

func (t *Tv) on() {
	t.isRunning = true
	fmt.Println("Turning tv on")
}

func (t *Tv) off() {
	t.isRunning = false
	fmt.Println("Turning tv off")
}

func main() {
	tv := &Tv{}

	onCommand := &OnCommand{
		device: tv,
	}

	offCommand := &OffCommand{
		device: tv,
	}

	onButton := &Button{
		command: onCommand,
	}
	onButton.press()

	offButton := &Button{
		command: offCommand,
	}
	offButton.press()
}
